<title>Instruction Reference</title>

<h1>Instruction Reference</h1>

You are required to implement the functionality of the following instruction 
set.
You are encouraged to add, subtract, or combine the instructions for better 
performance.
The instruction descriptions are given below.  The MIPS R3000 encodings are
only provided as a sample; they are not a standard.  The <strong>x</strong>'s in the encoding
are place holders for parameters.
Unless otherwise specified, the destination register is the first register 
listed in the syntax.  Click <a href="format.html">here</a> for questions about
format.

<h3>ADD -- <i>add (signed)</i></h3>
<table border>
<tr><td>Description:<td>adds two registers and stores the result in a register
<tr><td>Syntax:     <td>ADD rd,rs,rt
<tr><td>Format:     <td>R-type
<tr><td>Encoding:   <td><code>0000 00xx xxxx xxxx xxxx x000 0010 0000</code>
</table>

<h3>ADDI -- <i>add immediate</i></h3>
<table border>
<tr><td>Description:<td>adds an immediate value to a register and stores the result in a register
<tr><td>Syntax:     <td>ADDI rt,rs,immediate
<tr><td>Format:     <td>I-type
<tr><td>Encoding:   <td><code>0010 00xx xxxx xxxx xxxx xxxx xxxx xxxx</code>
</table>
<i>Warning:  <strong>lcc</strong> will not output this instruction.  It will 
output <strong>addu</strong> with an immediate value. </i>

<h3>ADDU -- <i>add unsigned</i></h3>
<table border>
<tr><td>Description:<td>adds two registers and stores the result in a register
<tr><td>Syntax:     <td>ADDU rd,rs,rt
<tr><td>Format:     <td>R-type
<tr><td>Encoding:   <td><code>0000 00xx xxxx xxxx xxxx x000 0010 0001</code>
</table>

<h3>AND -- <i>bitwise and</i></h3>
<table border>
<tr><td>Description:<td>bitwise ands two registers and stores the result in a register
<tr><td>Syntax:     <td>AND rd,rs,rt
<tr><td>Format:     <td>R-type
<tr><td>Encoding:   <td><code>0000 00xx xxxx xxxx xxxx x000 0010 0100</code>
</table>

<h3>ANDI -- <i>bitwise and immediate</i></h3>
<table border>
<tr><td>Description:<td>bitwise ands an immediate value with a register and stores the result in a register
<tr><td>Syntax:     <td>ANDI rt,rs,immediate
<tr><td>Format:     <td>I-type
<tr><td>Encoding:   <td><code>0011 00xx xxxx xxxx xxxx xxxx xxxx xxxx</code>
</table>
<i>Warning:  <strong>lcc</strong> will not output this instruction.  It will 
output <strong>and</strong> with an immediate value. </i>

<p>
<strong>Note about conditional branches</strong>: 
<p> <strong>Lcc</strong>
<ul>
 <li>outputs all branches in the form <br>
 op   rs,rt,offset 
 <li>produces signed and unsigned branches
</ul> <p>
 The MIPS architecture 
<ul>
 <li>expects branches in the form  <br>
 op   rs,offset <br>
 <li>compares rs to zero (except for BEQ and BNE which have 2 registers).  
 This presents difficulties when lcc produces an unsigned branch.
</ul>
<p>This is a good place to modify instructions. <p>


<h3>BEQ -- <i>branch if equal</i></h3>
<table border>
<tr><td>Description:<td>branches if the registers are equal
<tr><td>Syntax:     <td>BEQ rs,rt,offset
<tr><td>Format:     <td>I-type
<tr><td>Encoding:   <td><code>0001 00xx xxxx xxxx xxxx xxxx xxxx xxxx</code>
</table>

<h3>BGEZ -- <i>branch if greater than or equal to zero</i></h3>
<table border>
<tr><td>Description:<td>branches if rs is greater than or equal to zero
<tr><td>Syntax:     <td>BGEZ rs,offset
<tr><td>Format:     <td>I-type
<tr><td>Encoding:   <td><code>0000 01xx xxx0 0001 xxxx xxxx xxxx xxxx</code>
</table>

<h3>BGTZ -- <i>branch if greater than zero</i></h3>
<table border>
<tr><td>Description:<td>branches if rs is greater than zero
<tr><td>Syntax:     <td>BGTZ rs,offset
<tr><td>Format:     <td>I-type
<tr><td>Encoding:   <td><code>0001 11xx xxx0 0000 xxxx xxxx xxxx xxxx</code>
</table>

<h3>BLEZ -- <i>branch if less than or equal to zero</i></h3>
<table border>
<tr><td>Description:<td>branches if rs is less than or equal to zero
<tr><td>Syntax:     <td>BLEZ rs,offset
<tr><td>Format:     <td>I-type
<tr><td>Encoding:   <td><code>0001 10xx xxx0 0000 xxxx xxxx xxxx xxxx</code>
</table>

<h3>BLTZ -- <i>branch if less than zero</i></h3>
<table border>
<tr><td>Description:<td>branches if rs is less than zero
<tr><td>Syntax:     <td>BLTZ rs,offset
<tr><td>Format:     <td>I-type
<tr><td>Encoding:   <td><code>0000 01xx xxx0 0000 xxxx xxxx xxxx xxxx</code>
</table>

<h3>BNE -- <i>branch if not equal </i></h3>
<table border>
<tr><td>Description:<td>branches if the registers are not equal
<tr><td>Syntax:     <td>BNE rs,rt,offset
<tr><td>Format:     <td>I-type
<tr><td>Encoding:   <td><code>0001 01xx xxxx xxxx xxxx xxxx xxxx xxxx</code>
</table>

<h3>DIV -- <i>divide</i></h3>
<table border>
<tr><td>Description:<td>divides two registers and stores the result in a register 
<tr><td>Syntax:     <td>DIV rd,rs,rt
<tr><td>Format:     <td>R-type
<tr><td>Encoding:   <td><code>0000 00xx xxxx xxxx xxxx x000 0001 1010</code>
</table>

<h3>DIVU -- <i>divide unsigned</i></h3>
<table border>
<tr><td>Description:<td>divides two registers and stores the result in a register 
<tr><td>Syntax:     <td>DIVU rd,rs,rt
<tr><td>Format:     <td>R-type
<tr><td>Encoding:   <td><code>0000 00xx xxxx xxxx xxxx x000 0001 1011</code>
</table>

<h3>ERET -- <i>exception return</i></h3>
<table border>
<tr><td>Description:<td>returns from a system call, trap, or interrupt.
<tr><td>Syntax:     <td>ERET
<tr><td>Encoding:   <td><code>0100 0010 0000 0000 0000 0000 0001 1000</code>
</table>
Note:  ERET automatically returns to the address in $31.

<h3>J -- <i>jump</i></h3>
<table border>
<tr><td>Description:<td>unconditionally branches to <strong>target</strong>.
<tr><td>Syntax:     <td>J target
<tr><td>Format:     <td>J-type
<tr><td>Encoding:   <td><code>0000 10xx xxxx xxxx xxxx xxxx xxxx xxxx</code>
</table>

<h3>JAL -- <i>jump and link</i></h3>
<table border>
<tr><td>Description:<td>unconditionally branches to a subroutine, storing the return address in a register
<tr><td>Syntax:     <td>JAL target
<tr><td>Format:     <td>J-type
<tr><td>Encoding:   <td><code>0000 11xx xxxx xxxx xxxx xxxx xxxx xxxx</code>
</table>
Note:  JAL automatically stores the return address in $31.  Implement that in
the simulator, not the assembler.

<h3>JR -- <i>jump register</i></h3>
<table border>
<tr><td>Description:<td>unconditionally branches to the address stored in a register
<tr><td>Syntax:     <td>JR rs
<tr><td>Format:     <td>R-type
<tr><td>Encoding:   <td><code>0000 00xx xxx0 0000 0000 0000 0000 1000</code>
</table>

<h3>LA -- <i>load address</i></h3>
<table border>
<tr><td>Description:<td>load a value from a source into a register
<tr><td>Syntax:     <td>LA rs,source
<tr><td>Format:     <td>R-type
</table>
Note:  This is a pseudo-instruction generated by lcc.  MIPS does not accept it. 
You will need to handle this instruction in your assembler.
Source can be a register, an immediate, a label, or an offset (like 4($24)).  In
the case of this offset, 4 is added to the value in $24 and stored in rt.

<h3>LB -- <i>load byte</i></h3>
<table border>
<tr><td>Description:<td>loads one sign-extended byte of memory into a register
<tr><td>Syntax:     <td>LB rt,offset(rs)
<tr><td>Format:     <td>I-type
<tr><td>Encoding:   <td><code>1000 00xx xxxx xxxx xxxx xxxx xxxx xxxx</code>
</table>
Note:  The offset is added to the contents of <strong>rs</strong> to form an
address; the byte at that address is sign-extended and loaded into 
<strong>rt</strong>.

<h3>LBU -- <i>load byte unsigned</i></h3>
<table border>
<tr><td>Description:<td>loads one zero-extended byte of memory into a register
<tr><td>Syntax:     <td>LBU rt,offset(rs)
<tr><td>Format:     <td>I-type
<tr><td>Encoding:   <td><code>1001 00xx xxxx xxxx xxxx xxxx xxxx xxxx</code>
</table>
Note:  The offset is added to the contents of <strong>rs</strong> to form an
address; the byte at that address is zero-extended and loaded into 
<strong>rt</strong>.

<h3>LH -- <i>load halfword</i></h3>
<table border>
<tr><td>Description:<td>loads two sign-extended bytes of memory into a register
<tr><td>Syntax:     <td>LH rt,offset(rs)
<tr><td>Format:     <td>I-type
<tr><td>Encoding:   <td><code>1000 01xx xxxx xxxx xxxx xxxx xxxx xxxx</code>
</table>
Note:  The offset is added to the contents of <strong>rs</strong> to form an
address; the 2 bytes at that address are sign-extended and loaded into 
<strong>rt</strong>.

<h3>LHU -- <i>load halfword unsigned</i></h3>
<table border>
<tr><td>Description:<td>loads two zero-extended bytes of memory into a register
<tr><td>Syntax:     <td>LHU rt,offset(rs)
<tr><td>Format:     <td>I-type
<tr><td>Encoding:   <td><code>1001 01xx xxxx xxxx xxxx xxxx xxxx xxxx</code>
</table>
Note:  The offset is added to the contents of <strong>rs</strong> to form an
address; the 2 bytes at that address are zero-extended and loaded into 
<strong>rt</strong>.

<h3>LUI -- <i>load upper immediate</i></h3>
<table border>
<tr><td>Description:<td>concatenates an immediate value with 16 bits of zeroes and stores the result in a register
<tr><td>Syntax:     <td>LUI rt,immediate
<tr><td>Format:     <td>I-type
<tr><td>Encoding:   <td><code>0011 1100 000x xxxx xxxx xxxx xxxx xxxx</code>
</table>

<h3>LW -- <i>load word</i></h3>
<table border>
<tr><td>Description:<td>loads one word of memory into a register
<tr><td>Syntax:     <td>LW rt,offset(rs)
<tr><td>Format:     <td>I-type
<tr><td>Encoding:   <td><code>1000 11xx xxxx xxxx xxxx xxxx xxxx xxxx</code>
</table>
Note:  The offset is added to the contents of <strong>rs</strong> to form an
address; the word at that address is loaded into <strong>rt</strong>.

<h3>MOVE -- <i>move a value into a register</i></h3>
<table border>
<tr><td>Description:<td>moves a value from one register (rt) to another (rs).
<tr><td>Syntax:     <td>MOVE rs,rt
<tr><td>Format:     <td>R-type
</table>
Note:  This is a pseudo-instruction generated by lcc.  MIPS does not accept it.  You will need to handle this instruction in your assembler.

<h3>MULT -- <i>multiply</i></h3>
<table border>
<tr><td>Description:<td>multiplies two registers and stores the result in a register 
<tr><td>Syntax:     <td>MULT rd,rs,rt
<tr><td>Format:     <td>R-type
<tr><td>Encoding:   <td><code>0000 00xx xxxx xxxx xxxx x000 0001 1000</code>
</table>

<h3>MULTU -- <i>multiply unsigned</i></h3>
<table border>
<tr><td>Description:<td>multiplies two registers and stores the result in a register 
<tr><td>Syntax:     <td>MULTU rd,rs,rt
<tr><td>Format:     <td>R-type
<tr><td>Encoding:   <td><code>0000 00xx xxxx xxxx xxxx x000 0001 1001</code>
</table>

<h3>NEGU -- <i>negation</i></h3>
<table border>
<tr><td>Description:<td>changes the sign of a value:  (NEGU(x) = NOT(X) + 1)
<tr><td>Syntax:     <td>NEGU rs,rt
<tr><td>Format:     <td>R-type
</table>
Note:  This is a pseudo-instruction generated by lcc.  MIPS does not accept it.  You will need to handle this instruction in your assembler.

<h3>NOT -- <i>bitwise not</i></h3>
<table border>
<tr><td>Description:<td>performs a bitwise not on a value 
<tr><td>Syntax:     <td>NOT rs,rt
<tr><td>Format:     <td>R-type
</table>
Note:  This is a pseudo-instruction generated by lcc.  MIPS does not accept it.  You will need to handle this instruction in your assembler.

<h3>OR -- <i>bitwise or</i></h3>
<table border>
<tr><td>Description:<td>ors two registers and stores the result in a register
<tr><td>Syntax:     <td>OR rd,rs,rt
<tr><td>Format:     <td>R-type
<tr><td>Encoding:   <td><code>0000 00xx xxxx xxxx xxxx x000 0010 0101</code>
</table>

<h3>ORI -- <i>bitwise or immediate</i></h3>
<table border>
<tr><td>Description:<td>ors an immediate value with a register and stores the result in a register
<tr><td>Syntax:     <td>ORI rt,rs,immediate
<tr><td>Format:     <td>I-type
<tr><td>Encoding:   <td><code>0011 01xx xxxx xxxx xxxx xxxx xxxx xxxx</code>
</table>
<i>Warning:  <strong>lcc</strong> will not output this instruction.  It will 
output <strong>or</strong> with an immediate value. </i>

<h3>SB -- <i>store byte</i></h3>
<table border>
<tr><td>Description:<td>stores the contents of a register into memory
<tr><td>Syntax:     <td>SB rt,offset(rs)
<tr><td>Format:     <td>I-type
<tr><td>Encoding:   <td><code>1010 00xx xxxx xxxx xxxx xxxx xxxx xxxx</code>
</table>
Note:  The offset is added to the contents of <strong>rs</strong> to form an
address; the least-significant byte in <strong>rt</strong> is stored at that 
location in memory.

<h3>SH -- <i>store halfword</i></h3>
<table border>
<tr><td>Description:<td>stores the contents of a register into memory
<tr><td>Syntax:     <td>SH rt,offset(rs)
<tr><td>Format:     <td>I-type
<tr><td>Encoding:   <td><code>1010 01xx xxxx xxxx xxxx xxxx xxxx xxxx</code>
</table>
Note:  The offset is added to the contents of <strong>rs</strong> to form an
address; the least-significant halfword in <strong>rt</strong> is stored at 
that location in memory.

<h3>SLL -- <i>shift left logical</i></h3>
<table border>
<tr><td>Description:<td>logically shifts a register left <strong>sa</strong> bits and 
stores the result in a register
<tr><td>Syntax:     <td>SLL rd,rt,sa
<tr><td>Format:     <td>R-type
<tr><td>Encoding:   <td><code>0000 0000 000x xxxx xxxx xxxx xx00 0000</code>
</table>

<h3>SRA -- <i>shift right arithmetic</i></h3>
<table border>
<tr><td>Description:<td>arithmetically shifts a register right 
<strong>sa</strong> bits and stores the result in a register
<tr><td>Syntax:     <td>SRA rd,rt,sa
<tr><td>Format:     <td>R-type
<tr><td>Encoding:   <td><code>0000 0000 000x xxxx xxxx xxxx xx00 0011</code>
</table>

<h3>SRL -- <i>shift right logical</i></h3>
<table border>
<tr><td>Description:<td>logically shifts a register right <strong>sa</strong> bits and stores the result in a register
<tr><td>Syntax:     <td>SRL rd,rt,sa
<tr><td>Format:     <td>R-type
<tr><td>Encoding:   <td><code>0000 0000 000x xxxx xxxx xxxx xx00 0010</code>
</table>

<h3>SUB -- <i>subtract (signed)</i></h3>
<table border>
<tr><td>Description:<td>subtracts one register from another and stores the result in a register
<tr><td>Syntax:     <td>SUB rd,rs,rt
<tr><td>Format:     <td>R-type
<tr><td>Encoding:   <td><code>0000 00xx xxxx xxxx xxxx x000 0010 0010</code>
</table>

<h3>SUBU -- <i>subtract unsigned</i></h3>
<table border>
<tr><td>Description:<td>subtracts one register from another and stores the result in a register
<tr><td>Syntax:     <td>SUBU rd,rs,rt
<tr><td>Format:     <td>R-type
<tr><td>Encoding:   <td><code>0000 00xx xxxx xxxx xxxx x000 0010 0011</code>
</table>

<h3>SW -- <i>store word</i></h3>
<table border>
<tr><td>Description:<td>stores the contents of a register into memory
<tr><td>Syntax:     <td>SW rt,offset(rs)
<tr><td>Format:     <td>I-type
<tr><td>Encoding:   <td><code>1010 11xx xxxx xxxx xxxx xxxx xxxx xxxx</code>
</table>
Note:  The offset is added to the contents of <strong>rs</strong> to form an
address; the word in <strong>rt</strong> is stored at that location in memory.

<h3>SYSCALL -- <i>system call</i></h3>
<table border>
<tr><td>Description:<td>transfers control to the system
<tr><td>Syntax:     <td>SYSCALL code
<tr><td>Encoding:   <td><code>0000 00xx xxxx xxxx xxxx xxxx xx00 1111</code>
</table>
Note:  Code is a value that corresponds to a system call.

<h3>XOR -- <i>bitwise exclusive or</i></h3>
<table border>
<tr><td>Description:<td>exclusive ors two registers and stores the result in a register
<tr><td>Syntax:     <td>XOR rd,rs,rt
<tr><td>Format:     <td>R-type
<tr><td>Encoding:   <td><code>0000 00xx xxxx xxxx xxxx x000 0010 0110</code>
</table>

<h3>XORI -- <i>bitwise exclusive or immediate</i></h3>
<table border>
<tr><td>Description:<td>exclusive ors an immediate value with a register and stores the result in a register
<tr><td>Syntax:     <td>XORI rt,rs,immediate
<tr><td>Format:     <td>I-type
<tr><td>Encoding:   <td><code>0011 10xx xxxx xxxx xxxx xxxx xxxx xxxx</code>
</table>
<i>Warning:  <strong>lcc</strong> will not output this instruction.  It will 
output <strong>xor</strong> with an immediate value. </i>
<p>

<hr><hr>

<h1>Floating Point Instructions</h1>

<h3>ADD.fmt -- <i>add</i></h3>
<table border>
<tr><td>Description:<td>adds two registers and stores the result in a register
<tr><td>Syntax:     <td>ADD.fmt fd,fs,ft
<tr><td>Format:     <td>R-type (D and S formats possible)
<tr><td>Encoding:   <td><code>0100 01xx xxxx xxxx xxxx xxxx xx00 0000</code>
</table>

<h3>BC1F -- <i>Branch on FPU False</i></h3>
<table border>
<tr><td>Description:<td>Branch when a compare results in false
<tr><td>Syntax:     <td>BC1F offset
<tr><td>Format:     <td>I-type 
<tr><td>Encoding:   <td><code>0100 0101 0000 0000 xxxx xxxx xxxx xxxx</code>
</table>

<h3>BC1T -- <i>Branch on FPU True</i></h3>
<table border>
<tr><td>Description:<td>Branch when a compare results in true
<tr><td>Syntax:     <td>BC1T offset
<tr><td>Format:     <td>I-type 
<tr><td>Encoding:   <td><code>0100 0101 0000 0001 xxxx xxxx xxxx xxxx</code>
</table>

<h3>C.EQ.fmt -- <i>Compare - equal</i></h3>
<table border>
<tr><td>Description:<td>compares 2 registers to see if they are equal
<tr><td>Syntax:     <td>C.EQ.fmt fs,ft
<tr><td>Format:     <td>R-type (D and S formats possible)
<tr><td>Encoding:   <td><code>0100 01xx xxxx xxxx xxxx x000 0011 0010</code>
</table>

<h3>C.LE.fmt -- <i>Compare - less than or equal</i></h3>
<table border>
<tr><td>Description:<td>compares 2 registers to see if they are less than or equal
<tr><td>Syntax:     <td>C.LE.fmt fs,ft
<tr><td>Format:     <td>R-type (D and S formats possible)
<tr><td>Encoding:   <td><code>0100 01xx xxxx xxxx xxxx x000 0011 1110</code>
</table>

<h3>C.LT.fmt -- <i>Compare - less than</i></h3>
<table border>
<tr><td>Description:<td>compares 2 registers to see if one is less than the other
<tr><td>Syntax:     <td>C.LT.fmt fs,ft
<tr><td>Format:     <td>R-type (D and S formats possible)
<tr><td>Encoding:   <td><code>0100 01xx xxxx xxxx xxxx x000 0011 1100</code>
</table>

<h3>CVT.D.fmt -- <i>FP Convert to Double FP </i></h3>
<table border>
<tr><td>Description:<td>converts the contents of fs from <strong>fmt</strong> to double precision binary floating-point
<tr><td>Syntax:     <td>CVT.D.fmt fd,fs
<tr><td>Format:     <td>R-type (W and S formats possible)
<tr><td>Encoding:   <td><code>0100 01xx xxx0 0000 xxxx xxxx xx10 0001</code>
</table>

<h3>CVT.S.fmt -- <i>FP Convert to Single FP </i></h3>
<table border>
<tr><td>Description:<td>converts the contents of fs from <strong>fmt</strong> to single precision binary floating-point
<tr><td>Syntax:     <td>CVT.S.fmt fd,fs
<tr><td>Format:     <td>R-type (W and D formats possible)
<tr><td>Encoding:   <td><code>0100 01xx xxx0 0000 xxxx xxxx xx10 0000</code>
</table>

<h3>DIV.fmt -- <i>divide</i></h3>
<table border>
<tr><td>Description:<td>divides two registers and stores the result in a register
<tr><td>Syntax:     <td>DIV.fmt fd,fs,ft
<tr><td>Format:     <td>R-type (D and S formats possible)
<tr><td>Encoding:   <td><code>0100 01xx xxxx xxxx xxxx xxxx xx00 0011</code>
</table>

<h3>LDC1 -- <i>Load Doubleword to FPU (Coprocessor 1)</i></h3>
<table border>
<tr><td>Description:<td>Loads a doubleword from memory into <strong>ft</strong>
<tr><td>Syntax:     <td>LDC1 ft,offset(base)
<tr><td>Format:     <td>FP I-type 
<tr><td>Encoding:   <td><code>1101 01xx xxxx xxxx xxxx xxxx xxxx xxxx</code>
</table>
Note:  This is equivalent to <strong>lcc</strong>'s pseudo-instruction <strong>l.d</strong>.  

<h3>LWC1 -- <i>Load Word to FPU</i></h3>
<table border>
<tr><td>Description:<td>Loads a word from memory into <strong>ft</strong>
<tr><td>Syntax:     <td>LWC1 ft,offset(base)
<tr><td>Format:     <td>FP I-type 
<tr><td>Encoding:   <td><code>1100 01xx xxxx xxxx xxxx xxxx xxxx xxxx</code>
</table>
Note:  This is equivalent to <strong>lcc</strong>'s pseudo-instruction <strong>l.s</strong>.  

<h3>MFC1 -- <i>Move from FPU</i></h3>
<table border>
<tr><td>Description:<td>Moves a value from FPU register <strong>fs</strong> to CPU register <strong>rt</strong>  
<tr><td>Syntax:     <td>MFC1 rt,fs
<tr><td>Format:     <td>R-type 
<tr><td>Encoding:   <td><code>0100 0100 000x xxxx xxxx x000 0000 0000</code>
</table>

<h3>MOV.fmt -- <i>Floating point move</i></h3>
<table border>
<tr><td>Description:<td>the value in register fs is interpreted in the specified <strong>fmt</strong> and copied to register fd
<tr><td>Syntax:     <td>MOV.fmt fd,fs
<tr><td>Format:     <td>R-type (D and S formats possible)
<tr><td>Encoding:   <td><code>0100 01xx xxx0 0000 xxxx xxxx xx00 0110</code>
</table>

<h3>MTC1 -- <i>Move to FPU</i></h3>
<table border>
<tr><td>Description:<td>Moves a value from CPU register <strong>rt</strong> to FPU register <strong>fs</strong> 
<tr><td>Syntax:     <td>MTC1 rt,fs
<tr><td>Format:     <td>R-type 
<tr><td>Encoding:   <td><code>0100 0100 100x xxxx xxxx x000 0000 0000</code>
</table>

<h3>MUL.fmt -- <i>multiply</i></h3>
<table border>
<tr><td>Description:<td>multiplies two registers and stores the result in a register
<tr><td>Syntax:     <td>MUL.fmt fd,fs,ft
<tr><td>Format:     <td>R-type (D and S formats possible)
<tr><td>Encoding:   <td><code>0100 01xx xxxx xxxx xxxx xxxx xx00 0010</code>
</table>

<h3>NEG.fmt -- <i>Floating point negate</i></h3>
<table border>
<tr><td>Description:<td>the value in register fs is interpreted in the specified <strong>fmt</strong> and the sign bit is changed
<tr><td>Syntax:     <td>NEG.fmt fd,fs
<tr><td>Format:     <td>R-type (D and S formats possible)
<tr><td>Encoding:   <td><code>0100 01xx xxx0 0000 xxxx xxxx xx00 0111</code>
</table>

<h3>SDC1 -- <i>Store Doubleword to FPU</i></h3>
<table border>
<tr><td>Description:<td>Stores a doubleword from <strong>ft</strong> into memory 
<tr><td>Syntax:     <td>SDC1 ft,offset(base)
<tr><td>Format:     <td>FP I-type 
<tr><td>Encoding:   <td><code>1111 01xx xxxx xxxx xxxx xxxx xxxx xxxx</code>
</table>
Note:  This is equivalent to <strong>lcc</strong>'s pseudo-instruction <strong>s.d</strong>.  

<h3>SWC1 -- <i>Store Word to FPU</i></h3>
<table border>
<tr><td>Description:<td>Stores a word from <strong>ft</strong> into memory 
<tr><td>Syntax:     <td>SWC1 ft,offset(base)
<tr><td>Format:     <td>FP I-type 
<tr><td>Encoding:   <td><code>1110 01xx xxxx xxxx xxxx xxxx xxxx xxxx</code>
</table>
Note:  This is equivalent to <strong>lcc</strong>'s pseudo-instruction <strong>s.s</strong>.  

<h3>SUB.fmt -- <i>subtract</i></h3>
<table border>
<tr><td>Description:<td>subtracts two registers and stores the result in a register
<tr><td>Syntax:     <td>SUB.fmt fd,fs,ft
<tr><td>Format:     <td>R-type (D and S formats possible)
<tr><td>Encoding:   <td><code>0100 01xx xxxx xxxx xxxx xxxx xx00 0001</code>
</table>

<h3>TRUNC.W.fmt -- <i>Truncate to Single Fixed-Point Format</i></h3>
<table border>
<tr><td>Description:<td>the value in register fs is arithmetically converted to single fixed-point format
<tr><td>Syntax:     <td>TRUNC.W.fmt fd,fs
<tr><td>Format:     <td>R-type (D and S formats possible)
<tr><td>Encoding:   <td><code>0100 01xx xxx0 0000 xxxx xxxx xx00 1101</code>
</table>

<p><hr>
<i>This information was taken from the <strong>MIPS R4000 User's Guide</strong>.</i>
