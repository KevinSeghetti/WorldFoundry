// propshet.cc

#include <attrib/buttons/button.hp>
#include <attrib/buttons/propshet.hp>
#include <commctrl.h>

#pragma comment( lib, "comctl32" )

HWND hwndTabControl = 0;
HIMAGELIST hSmall = 0;
HIMAGELIST hLarge = 0;

RollUp::RollUp( typeDescriptor* td ) : uiDialog( td )
{
//	extern typeDescriptor* pEndOfTypeDescriptors;

	_bSave = true;
#if 0
	if ( ( _nLinesInRollup = td->xdata.rollUpLength ) == 0 )
	{	// Calculate
		for ( ++td; td < pEndOfTypeDescriptors && td->type != BUTTON_PROPERTY_SHEET; ++td )
		{
			if ( td->showAs != SHOW_AS_HIDDEN )
				++_nLinesInRollup;
//			if ( td->type == BUTTON_GROUP_START )
//				--_nLinesInRollup;
			if ( td->type == BUTTON_MESHNAME )
			{	// Mesh name uses two lines
				++_nLinesInRollup;
			}
		}
	}
#endif
}


RollUp::~RollUp()
{
//	assert( _hPanel );
//	theAttributes.ip->DeleteRollupPage( _hPanel );
}


int
RollUp::storedDataSize() const
{
	return uiDialog::storedDataSize() + sizeof( int32 );
}


dataValidation
RollUp::copy_to_xdata( byte* & saveData )
{
	uiDialog::copy_to_xdata( saveData );

#if 1
	int32 i = 0;
#else
	assert( _hPanel );
	int32 i = IsRollupPanelOpen( _hPanel );

	{
	assert( _hPanel );
	HWND mainPanel = GetParent( GetParent( GetParent( _hPanel ) ) );
	assert( mainPanel );
	IRollupWindow* pRollup = GetIRollup( mainPanel );
	assert( pRollup );
	int idxRollup = pRollup->GetPanelIndex( _hPanel );
	assert( IsRollupPanelOpen( _hPanel ) == pRollup->IsPanelOpen( idxRollup ) );
	ReleaseIRollup( pRollup );
	}
#endif

	(*(int32*)saveData) = i, saveData += sizeof( int32 );

	return DATA_OK;
}


void
RollUp::reset()
{
	assert( _td );
	reset( _td->def );
}


void
RollUp::reset( int32 i )
{
	assert( _td->min <= i && i <= _td->max );
#pragma message( "TODO: Make sheet active" )
}


void
RollUp::reset( byte* & saveData )
{
	_bUserOverrideEnable = true;
	byte* pSaveData = saveData;
	reset( *((int32*)pSaveData) );
	saveData += sizeof( int32 );
}


extern BOOL CALLBACK AttributesDlgProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam );

double
RollUp::eval() const
{
	assert( _hPanel );
	//return double( IsRollupPanelOpen( _hPanel ) );
	return 1.0;
}


bool
RollUp::enable( bool )
{
	return uiDialog::enable( true );
}


unsigned char factory[] =
{
	0x00,0x00,0x01,0x00,0x01,0x00,0x20,0x20,0x10,0x00,0x00,0x00,0x00,0x00,0xe8,0x02,0x00,0x00,0x16,0x00,
	0x00,0x00,0x28,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x01,0x00,0x04,0x00,0x00,0x00,
	0x00,0x00,0x80,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x80,0x00,0x80,0x00,
	0x00,0x00,0x80,0x00,0x80,0x00,0x80,0x80,0x00,0x00,0xc0,0xc0,0xc0,0x00,0x80,0x80,0x80,0x00,0x00,0x00,
	0xff,0x00,0x00,0xff,0x00,0x00,0x00,0xff,0xff,0x00,0xff,0x00,0x00,0x00,0xff,0x00,0xff,0x00,0xff,0xff,
	0x00,0x00,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x99,0x99,0x99,0x10,0x8f,0xf7,
	0x7f,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x99,0x99,0x91,0x08,0xff,0xf7,0x77,0xff,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x99,0x99,0x10,0x0f,0xff,0xf7,0x77,0x77,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x99,0x91,0x00,0x8f,0xff,0xff,0x77,0x77,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x99,0x10,
	0x00,0x07,0xff,0xff,0x77,0x77,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x11,0x00,0x00,0x08,0xff,0xf7,
	0x77,0x77,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x8f,0xf7,0x77,0x7f,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xf7,0x77,0x77,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x08,0xff,0x77,0x77,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x7f,0xf7,0x77,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x8f,
	0xff,0x77,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0xff,0xff,0x77,0x77,
	0x77,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x8f,0xff,0xff,0xff,0xff,0xff,0xf7,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0xff,0xff,0xff,0xff,0xf7,0x77,0x80,0x00,0x00,0x00,0x00,0x08,
	0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x08,0x80,0x00,0x00,0x08,
	0xff,0xff,0xff,0xff,0xff,0xff,0xf8,0x00,0x00,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x7f,0xff,0xff,0xff,
	0xff,0xff,0xff,0x80,0x00,0x00,0x70,0x00,0x87,0x08,0xf8,0x00,0x8f,0xff,0x7f,0x77,0x77,0xff,0xff,0x70,
	0x00,0x00,0x88,0x00,0x07,0x7f,0xff,0x80,0x07,0xff,0xf7,0xff,0xf7,0x77,0xff,0xf7,0x80,0x00,0x0f,0x00,
	0x08,0xff,0xff,0x70,0x08,0xff,0xff,0xff,0xff,0xff,0x7f,0xff,0x70,0x00,0x08,0x70,0x00,0x7f,0xff,0xf8,
	0x00,0x7f,0x7f,0xff,0xff,0xff,0xf7,0x7f,0xf8,0x00,0x00,0xf8,0x00,0x8f,0xff,0xff,0x88,0xff,0xff,0xf7,
	0xff,0xff,0xff,0x7f,0xff,0x80,0x00,0x8f,0x00,0x07,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf7,
	0xff,0x70,0x00,0x0f,0x70,0x08,0xff,0xff,0xff,0xff,0xff,0xf7,0xff,0xff,0xff,0xff,0x7f,0xf8,0x00,0x08,
	0xf8,0x00,0x7f,0xff,0xff,0xff,0x7f,0xff,0xff,0xff,0xff,0x77,0x7f,0xff,0x00,0x00,0xff,0x00,0x8f,0xff,
	0xf7,0xf7,0x7f,0xff,0xff,0xff,0xff,0x77,0x7f,0xff,0x70,0x00,0x8f,0x80,0x07,0xff,0xff,0x77,0xff,0xff,
	0xff,0xff,0xf7,0x77,0x7f,0xff,0xf8,0x00,0x0f,0xf8,0x08,0xff,0xf7,0x77,0xff,0xff,0xf7,0x77,0x77,0x77,
	0x7f,0xff,0xff,0x00,0x08,0xf7,0x87,0xff,0xf7,0x77,0xff,0x7f,0x77,0x77,0x77,0x77,0xff,0xff,0xff,0x70,
	0x00,0xff,0xff,0xff,0xf7,0x7f,0xff,0xff,0x77,0x77,0x77,0x7f,0xff,0xff,0xff,0xf8,0x00,0x8f,0xff,0xf7,
	0x7f,0xff,0xff,0xff,0x77,0x77,0x77,0x77,0xff,0xff,0xff,0xf7,0x00,0x0f,0xff,0xf7,0x77,0xff,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00
};
#define factorySize 766

#if 0
// The following two structs are for the use of this program in
// manipulating icons. They are more closely tied to the operation
// of this program than the structures listed above. One of the
// main differences is that they provide a pointer to the DIB
// information of the masks.
typedef struct
{
	UINT			Width, Height, Colors; // Width, Height and bpp
	LPBYTE			lpBits;                // ptr to DIB bits
	DWORD			dwNumBytes;            // how many bytes?
	LPBITMAPINFO	lpbi;                  // ptr to header
	LPBYTE			lpXOR;                 // ptr to XOR image bits
	LPBYTE			lpAND;                 // ptr to AND image bits
} ICONIMAGE, *LPICONIMAGE;
typedef struct
{
	BOOL		bHasChanged;                     // Has image changed?
	TCHAR		szOriginalICOFileName[MAX_PATH]; // Original name
	TCHAR		szOriginalDLLFileName[MAX_PATH]; // Original name
	UINT		nNumImages;                      // How many images?
	ICONIMAGE	IconImages[1];                   // Image entries
} ICONRESOURCE, *LPICONRESOURCE;


HICON
MakeIconFromResource( LPICONIMAGE lpIcon )
{
    HICON        	hIcon = NULL;

    // Sanity Check
    if( lpIcon == NULL )
        return NULL;
    if( lpIcon->lpBits == NULL )
        return NULL;
    // Let the OS do the real work :)
    hIcon = CreateIconFromResourceEx( lpIcon->lpBits, lpIcon->dwNumBytes, TRUE, 0x00030000,
            (*(LPBITMAPINFOHEADER)(lpIcon->lpBits)).biWidth, (*(LPBITMAPINFOHEADER)(lpIcon->lpBits)).biHeight/2, 0 );

    // It failed, odds are good we're on NT so try the non-Ex way
    if( hIcon == NULL )
    {
        // We would break on NT if we try with a 16bpp image
        if(lpIcon->lpbi->bmiHeader.biBitCount != 16)
        {
            hIcon = CreateIconFromResource( lpIcon->lpBits, lpIcon->dwNumBytes, TRUE, 0x00030000 );
        }
    }
    return hIcon;
}
#endif


int
RollUp::make_dialog_gadgets( HWND hPanel )
{
	int error;

	enum { MAX_Y = 36 };

	assert( _td );
	assert( ::hInstance );

	if ( !hwndTabControl )
	{
		RECT rcClient;

    	// Get the dimensions of the parent window's client area, and create a tab control child window of that size.
    	GetClientRect( hPanel, &rcClient );
    	hwndTabControl = CreateWindow(
			WC_TABCONTROL, "",
        	WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE | TCS_MULTILINE,	// | TCS_BOTTOM,
        	0, 0, rcClient.right, rcClient.bottom,
        	hPanel,
			NULL,
			::hInstance,
			NULL );
		assert( hwndTabControl );
		assert( theAttributes->_font );
		Button_SetFont( hwndTabControl, theAttributes->_font );

		assert( hSmall == 0 );
		hSmall = ImageList_Create( 16, 16, 0, 0, 1 );
		assert( hSmall );
		TabCtrl_SetImageList( hwndTabControl, hSmall );
	}

	assert( hwndTabControl );
	extern HWND retPanel;
	retPanel = hwndTabControl;
//	retPanel = hPanel;

#pragma message( "TODO: when iff, add optional icon chunk" )

	_idxImageIcon = ImageList_GetImageCount( hSmall );

	TC_ITEM tie;
    tie.mask = TCIF_TEXT | TCIF_IMAGE;

#if 1
	tie.iImage = -1;
#else
	HICON hIcon = LoadIcon( ::hInstance, MAKEINTRESOURCE( IDI_WORLDFOUNDRY ) );

	assert( hIcon );
	error = ImageList_AddIcon( hSmall, hIcon );
	assert( error != -1 );
	tie.iImage = _idxImageIcon;
#endif

    tie.pszText = _td->xdata.displayName;
	error = TabCtrl_InsertItem( hwndTabControl, TabCtrl_GetItemCount( hwndTabControl ), &tie );
	assert( error != -1 );

	assert( hPanel );
	assert( _td->name );

	reset();

	return 0;
}
