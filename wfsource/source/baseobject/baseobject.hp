//==============================================================================
// baseobject.hp:
// Copyright ( c ) 2003 World Foundry Group.  
// Part of the World Foundry 3D video game engine/production environment
// for more information about World Foundry, see www.worldfoundry.org
//==============================================================================
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// Version 2 as published by the Free Software Foundation
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
// or see www.fsf.org

//==============================================================================
// Description: all game objects need to be derived from this object
// since it is what the object list code refers to, as well as the asset handling code
//==============================================================================

#ifndef BASE_OBJECT_HP
#define BASE_OBJECT_HP

//==============================================================================

#include <memory/memory.hp>
#include <cpplib/iterwrapper.hp>
#include <cpplib/int16li.hp>
#include <cpplib/array.hp>
#include <mailbox/mailbox.hp>
#include "commonblock.hp"
#include "msgport.hp"
                              
//==============================================================================
                              
class BaseObject
{
public:
   BaseObject(const void* oadData,const CommonBlock& commonBlock); 
   virtual ~BaseObject();
   void Validate() const;

	bool sendMsg(const int16 msgType, const int32 msgData);
	bool sendMsg(const int16 msgType, const void* msgData,uint32 msgDataSize);

   virtual MsgPort& GetMsgPort() = 0;

   virtual Mailboxes& GetMailboxes() = 0;
   virtual const Mailboxes& GetMailboxes() const = 0;

   virtual void KillSelf() = 0;      // cause this object to get deleted from the world

	// room transitions
   // each derived class can override these if desired to get notified when their assets are loaded & unloaded
   // if you do this be sure the call the overridden function so that each class down the chain can deal with their assets
	virtual void BindAssets(Memory& memory);					// bind into current room
	virtual void UnBindAssets();				// unbind, get rid of all transient assets

	// object type enumeration, created from OAD data
	enum EActorKind
	{
#		include "oas/objects.e"				
		MAX_OBJECT_TYPES
	};

	virtual EActorKind kind() const = 0;         // manual RTTI, investigate removing

//------------------------------------------------------------------------------
protected:
   const CommonBlock& GetCommonBlock() const;
   const void* GetBlockPtr(int32 offset) const;

#if SW_DBSTREAM >= 1
	virtual std::ostream& Print( std::ostream& ) const = 0;
   friend std::ostream& operator << ( std::ostream& s, const BaseObject& obj );
#endif
   // Pointer to OAD data for this object.  Needs to be cast to the structure generated by the corresponding .ht file.
   // This data is *READ ONLY* and should not be modified.  In fact, multiple actors which all have the same OAD data
   // values all point to the same actual data bytes in order to save memory.
   const void*	const _oadData;

   const CommonBlock _commonBlock;           // this is the CommonBlock which the oadData offsets point into (probably the same for all objects) 
};

//==============================================================================

class BaseObjectIterator 
{
public:
    virtual BaseObject& operator*() = 0;
    virtual BaseObjectIterator& operator++() = 0;
    virtual BaseObjectIterator& operator+=(int offset);              // will do it the slow way by default
    virtual bool Empty() const = 0;
    virtual BaseObjectIterator* Copy() const = 0;
    void Validate() const;
    //virtual bool operator==(const BaseObjectIterator&) = 0;
    //bool operator!=(const BaseObjectIterator& other) { return !(*this == other); }
protected:
    virtual void _Validate() const=0;             // only to be called from Validate
private:
};

//==============================================================================

typedef IteratorWrapper<BaseObject,BaseObjectIterator> BaseObjectIteratorWrapper;

typedef Array<BaseObject*> BaseObjectList;

//==============================================================================

class BaseObjectIteratorFromInt16List : public BaseObjectIterator 
{
public:
   BaseObjectIteratorFromInt16List(const Int16ListIter& listIter, Array<BaseObject*>& objects ); 
   virtual ~BaseObjectIteratorFromInt16List(); 
   virtual BaseObject& operator*();
   virtual BaseObjectIterator& operator++();
	virtual bool Empty() const;
   virtual BaseObjectIterator* Copy() const;

   //virtual bool operator==(const BaseObjectIterator&);
protected:
    virtual void _Validate() const;             // only to be called from Validate
private:
   Int16ListIter _listIter;
   Array<BaseObject*>& _objects;
};

//==============================================================================
#include "baseobject.hpi"
//==============================================================================
#endif
//==============================================================================

